{"meta":{"title":"昆明鱼","subtitle":"一条走在技术路上的小鱼儿","description":"记录我的技术与生活","author":"kmfish","url":"http://kmfish.net"},"posts":[{"title":"MultiTypeListViewAdapter Android ListView 多type的Adapter封装","slug":"MultiTypeListViewAdapter","date":"2017-03-29T14:03:33.000Z","updated":"2017-04-01T10:22:27.000Z","comments":true,"path":"2017/03/29/MultiTypeListViewAdapter/","link":"","permalink":"http://kmfish.net/2017/03/29/MultiTypeListViewAdapter/","excerpt":"MultiTypeListViewAdapter 是什么？MultiTypeListViewAdapter，顾名思义。其封装了多type下的Adapter的编程模式，通过对每种type统一接口，利用多态的方式，将type的实现从Adapter中抽离出来。Adapter只需面向统一接口，所以可以提供一个通用实现，实现代码不再变动。而会变动的每个type对应的item实现，则由使用者自己去实现。对扩展开放，对修改封闭。\n同时，由于每个type的item均被抽离出来了。相当于复用的粒度为每个type item，可以根据需要，动态地选择合适的item去添加到adapter中。提高了代码复用，每个人编写维护好自己的item即可，避免了多人合作时都去修改Adapter，容易造成冲突。\n另外，由于ViewHolder 模式的规范，MultiTypeListViewAdapter也同时封装了ViewHolder模式。\n","text":"MultiTypeListViewAdapter 是什么？MultiTypeListViewAdapter，顾名思义。其封装了多type下的Adapter的编程模式，通过对每种type统一接口，利用多态的方式，将type的实现从Adapter中抽离出来。Adapter只需面向统一接口，所以可以提供一个通用实现，实现代码不再变动。而会变动的每个type对应的item实现，则由使用者自己去实现。对扩展开放，对修改封闭。 同时，由于每个type的item均被抽离出来了。相当于复用的粒度为每个type item，可以根据需要，动态地选择合适的item去添加到adapter中。提高了代码复用，每个人编写维护好自己的item即可，避免了多人合作时都去修改Adapter，容易造成冲突。 另外，由于ViewHolder 模式的规范，MultiTypeListViewAdapter也同时封装了ViewHolder模式。 常见的ListView Adapter 实现先看一下常见的ListAdapter 实现，分为单个type和多type两种情况。 1、单Type的Adapter12345678910111213141516171819202122232425262728293031323334353637383940414243class ListAdapter extend BaseAdapter &#123; ... private List&lt;String&gt; contents = new ArrayList(); ... public View getView(int position, View convertView, ViewGroup parent) &#123; String item = getItem(position); if(null == item) &#123; throw new RuntimeException(\"list item is never null. pos:\" + position); &#125; else &#123; ViewHolder holder; if(null == convertView) &#123; holder = createViewHolder(parent); convertView = holder.itemView; convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder)convertView.getTag(); &#125; item.updateHolder(holder, position); return convertView; &#125; &#125; &#125; private ViewHolder createViewHolder(ViewGroup parent) &#123; // create item view from layout xml ... &#125; private void updateHolder(ViewHolder holder, String item) &#123; // update item view holder.text.setText(item); &#125; private class ViewHolder &#123; TextView text; ViewHolder(View itemView) &#123; text = (TextView)itemView.findViewById(R.id.text); &#125; &#125; ...&#125; 应该是挺常见的写法吧，继续往下。 2、多type的adapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class ListAdapter extend BaseAdapter &#123; ... private List&lt;String&gt; contents = new ArrayList(); ... public int getItemViewType(int position) &#123; if (position % 2 == 0) &#123; return 0; &#125; return 1; &#125; public int getViewTypeCount() &#123; return 2; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; String item = getItem(position); if(null == item) &#123; throw new RuntimeException(\"list item is never null. pos:\" + position); &#125; else &#123; ViewHolder holder; if(null == convertView) &#123; if (getItemViewType(position) == 0) &#123; holder = createViewHolder(parent); &#125; else if (getItemViewType(position) == 1) &#123; holder = createViewHolder1(parent); &#125; convertView = holder.itemView; convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder)convertView.getTag(); &#125; if (getItemViewType(position) == 0) &#123; item.updateHolder(holder, position); &#125; else if (getItemViewType(position) == 1) &#123; item.updateHolder1(holder, position); &#125; return convertView; &#125; &#125; &#125; private ViewHolder createViewHolder(ViewGroup parent) &#123; // create item view from layout xml ... &#125; private void createViewHolder1(ViewGroup parent) &#123; // create item view from layout xml ... &#125; private void updateHolder(ViewHolder holder, String item) &#123; // update item view holder.text.setText(item); &#125; private void updateHolder1(ViewHolder1 holder, String item) &#123; // update item view holder.text.setText(item); holder.img.setImageResoure(R.drawable.img); &#125; private class ViewHolder &#123; TextView text; ViewHolder(View itemView) &#123; text = (TextView)itemView.findViewById(R.id.text); &#125; &#125; private class ViewHolder1 &#123; TextView text; ImageView img; ViewHolder(View itemView) &#123; text = (TextView)itemView.findViewById(R.id.text); img = (ImageView)itemView.findViewById(R.id.img); &#125; &#125; ...&#125; 看到这里，是否感觉这个Adapter的getView（）开始有些让人不舒服了呢。若type再进一步增加，难不成还得继续if/else下去，adapter变得又臭又长。估计往后下去，就再没人愿意维护了。而且，这个Adapter的这一堆代码还得到处重复写下去，每个有listView的地方，都得配套一个adapter。针对这个坑，我设计了MultiTypeListViewAdapter来解决。希望能帮助到有需要的程序猿们~ 使用 MultiTypeListViewAdapter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class MainActivity extends AppCompatActivity &#123; private ListView listView; private MultiTypeArrayAdapter adapter; private static final int ITEM_TYPE_1 = 0; private static final int ITEM_TYPE_2 = 1; private static final int ITEM_TYPE_COUNT = 2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); listView = (ListView) findViewById(R.id.listview); adapter = new MultiTypeArrayAdapter(ITEM_TYPE_COUNT); listView.setAdapter(adapter); setupAdapter(); &#125; private void setupAdapter() &#123; adapter.setTypeCount(ITEM_TYPE_COUNT); LineListItem1 item1 = new LineListItem1(this, ITEM_TYPE_1, \"line type 1\"); LineListItem2 item2 = new LineListItem2(this, ITEM_TYPE_2, \"line type 2\"); adapter.setNotifyOnChange(false); for (int i = 0, len = 50; i &lt; len; i++) &#123; adapter.addItem( i % 2 == 0 ? item1 : item2); &#125; adapter.notifyDataSetChanged(); &#125;&#125;public class LineListItem1 extends BaseListItem &#123; private String line; public LineListItem1(Context mContext, int viewType, String line) &#123; super(mContext, viewType); this.line = line; &#125; @Override protected int onGetItemLayoutRes() &#123; return R.layout.list_item1; &#125; @Override protected ViewHolder onCreateViewHolder(View itemView) &#123; return new LineViewHolder(itemView); &#125; @Override public void updateHolder(ViewHolder holder, int pos) &#123; LineViewHolder h = (LineViewHolder) holder; h.text.setText(line + \"_\" + pos); &#125; private class LineViewHolder extends ViewHolder &#123; TextView text; public LineViewHolder(View itemView) &#123; super(itemView); text = (TextView) itemView.findViewById(R.id.line_text); &#125; &#125;&#125;public class LineListItem2 extends BaseListItem &#123; private String line; public LineListItem2(Context mContext, int viewType, String line) &#123; super(mContext, viewType); this.line = line; &#125; @Override protected int onGetItemLayoutRes() &#123; return R.layout.list_item2; &#125; @Override protected ViewHolder onCreateViewHolder(View itemView) &#123; return new LineViewHolder2(itemView); &#125; @Override public void updateHolder(ViewHolder holder, int pos) &#123; LineViewHolder2 h = (LineViewHolder2) holder; h.text.setText(line + \"_\" + pos); h.img.setImageResource(R.drawable.icon_git); &#125; private class LineViewHolder2 extends ViewHolder &#123; ImageView img; TextView text; public LineViewHolder2(View itemView) &#123; super(itemView); img = (ImageView) itemView.findViewById(R.id.thumb); text = (TextView) itemView.findViewById(R.id.name); &#125; &#125;&#125; 可以看到，使用MultiTypeListViewAdapter之后，实现多type的Adapter变得相当简单了。再也不用面对一堆判断itemType的if/else了。每增加一种type，只需增加一种新的ListItem即可，再也不用去改动Adapter的代码了。 项目发布在github上了，MultiTypeListViewAdapter，欢迎fork和交流。","raw":null,"content":null,"categories":[],"tags":[{"name":"Android ListView Adapter ViewType","slug":"Android-ListView-Adapter-ViewType","permalink":"http://kmfish.net/tags/Android-ListView-Adapter-ViewType/"}]},{"title":"修复一例 BlockingQueue.poll 导致的线程While循环无限执行占用cpu的bug","slug":"fix-while-loop-cpu-use-problem-md","date":"2016-05-26T08:19:27.000Z","updated":"2017-04-01T10:22:11.000Z","comments":true,"path":"2016/05/26/fix-while-loop-cpu-use-problem-md/","link":"","permalink":"http://kmfish.net/2016/05/26/fix-while-loop-cpu-use-problem-md/","excerpt":"起因基于部分用户反馈使用我们的app时，玩游戏过程中会有卡顿现象出现，从而进行cpu使用率排查。","text":"起因基于部分用户反馈使用我们的app时，玩游戏过程中会有卡顿现象出现，从而进行cpu使用率排查。 发现问题今天先操作进入一个房间后，使用android的traceview跟踪了一段2s左右的cpu使用数据，然后通过traceview对其进行分析。 如图一所示，左边列出了该时间段内的线程，右边则图形化的显示了它们的cpu使用情况。很直观的能够发现，”GroupMsgTransport”这个线程几乎一直在占用cpu，比main线程还多的多。所以首先引起怀疑。 再进一步查看详细的cpu使用情况，发现占用cpu time最多的几项都是在对一个BlockingQueue的操作，选择这些行之后，也定位到了 “GroupMsgTransport”线程。说明这条线程一直在对Queue执行poll操作。通过在代码中搜索关键字，查找到了这个罪魁祸首。 定位原因最终定位到这段问题代码：1234567891011121314@Override public void run() &#123; android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); while (run) &#123; final ImGroupMsgInfo info; info = mMQ.poll(); // 罪魁祸首的一行， poll()方法在队列为空时会return null，从而就导致该循环无限执行下去，空耗了cpu if (info != null) &#123; //... &#125; else &#123; // do nothing &#125; &#125; &#125; 修复知道了根本原因后，修复的方法也很简单，将poll换为take() 即可，take方法在队列为空时会block住当前thread，从而不再占用cpu。1234567891011121314151617181920@Override public void run() &#123; android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); while (run) &#123; ImGroupMsgInfo msgInfo = null; try &#123; msgInfo = mMQ.take(); // 修改此处为take() &#125; catch (InterruptedException e) &#123; MLog.error(TAG, e); &#125; final ImGroupMsgInfo info = msgInfo; if (info != null) &#123; //... &#125; else &#123; // do nothing &#125; &#125; &#125; 结果对比修改之前，cpu占用高达近50%： 修改之后，cpu占用不到10%： 后记在修复了这一处问题后，又继续在项目里搜索了下使用poll()的地方，结果就又发现了一处一模一样的bug。。。以后可以多留意while(true)循环，要注意循环是否有正确的退出时机，或block的时机，避免出现类似问题。","raw":null,"content":null,"categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://kmfish.net/tags/性能优化/"}]},{"title":"切换到Hexo + GithubPages","slug":"change-to-hexo","date":"2016-01-17T07:02:55.000Z","updated":"2017-03-29T14:03:33.000Z","comments":true,"path":"2016/01/17/change-to-hexo/","link":"","permalink":"http://kmfish.net/2016/01/17/change-to-hexo/","excerpt":"","text":"博客之前用的是sina的SAE + press，也一直还不错。其实最早一开始用的是AWS的EC2，但连接速度实在太慢，才换到SAE的。然后参加活动获得了一些云豆，本以为够用蛮久的，结果最近一两个月，突然的访问把云豆都用光了。于是，就打算切换到githubpages上，昨晚在网上看了下hexo来搭建博客，看上去蛮不错的，于是就切换过来了。这次应该就不怕流量用完了，而且hexo的使用也蛮方便的，网上的各种资料也挺多，感谢这些作者，给大家带来了便利。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"android 子线程中更新界面？被ProgressBar给迷惑了","slug":"Can-update-view-in-background-thread","date":"2015-09-22T06:51:37.000Z","updated":"2017-04-01T10:23:23.000Z","comments":true,"path":"2015/09/22/Can-update-view-in-background-thread/","link":"","permalink":"http://kmfish.net/2015/09/22/Can-update-view-in-background-thread/","excerpt":"在看apidemos的例子RetainedFragement时，看到在Thread中执行了 这么一句1mProgressBar.setProgress(progress);\n且执行正常，progressbar确实一直在更新。顿觉疑惑，View在更新时，会检查当前线程是否是创建view所在的线程（即UI线程），若不一致，则会抛出异常的。","text":"在看apidemos的例子RetainedFragement时，看到在Thread中执行了 这么一句1mProgressBar.setProgress(progress); 且执行正常，progressbar确实一直在更新。顿觉疑惑，View在更新时，会检查当前线程是否是创建view所在的线程（即UI线程），若不一致，则会抛出异常的。 in ViewRootImpl.java 中：123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\"); &#125;&#125; 后来查看了setProgress（）的源码后，才恍然大悟，这个方法内已经处理了子线程里调用的情况了。 1234567891011121314151617181920212223242526272829303132333435363738394041@android.view.RemotableViewMethod public synchronized void setProgress(int progress) &#123; setProgress(progress, false); &#125; @android.view.RemotableViewMethod synchronized void setProgress(int progress, boolean fromUser) &#123; if (mIndeterminate) &#123; return; &#125; if (progress &lt; 0) &#123; progress = 0; &#125; if (progress &gt; mMax) &#123; progress = mMax; &#125; if (progress != mProgress) &#123; mProgress = progress; refreshProgress(R.id.progress, mProgress, fromUser); &#125; &#125; private synchronized void refreshProgress(int id, int progress, boolean fromUser) &#123; if (mUiThreadId == Thread.currentThread().getId()) &#123; doRefreshProgress(id, progress, fromUser, true); &#125; else &#123; if (mRefreshProgressRunnable == null) &#123; mRefreshProgressRunnable = new RefreshProgressRunnable(); &#125; final RefreshData rd = RefreshData.obtain(id, progress, fromUser); mRefreshData.add(rd); if (mAttached &amp;&amp; !mRefreshIsPosted) &#123; post(mRefreshProgressRunnable); mRefreshIsPosted = true; &#125; &#125; &#125; 关键就是refreshProgress（）了，这里处理了若当前线程不是ui thread，则将更新消息post到ui thread中去执行了。而且可以发现这几个方法都是加了同步控制的，是线程安全的，保证了多线程调用也是正常的了。 真的是“源码之下无秘密“啊。 p.s：之前一次面试的时候，对方有问到能否在子线程里更新界面？我回到不能，因为会抛出异常。对方接着问，为什么？我就答不上来了，现在的理解是，因为android下的界面更新不是线程安全的，所以要保证在单一线程中同步执行。其他线程要更新UI的话，需要通过handler，Looper消息机制把更新事情pass到UI thread的消息队列中，由UI thread来完成界面的更新绘制。面试官又继续问道，能否在子线程里去更新progressbar的进度呢？我当时回答的是不能，必须通过handler去发消息。但现在看来progressbar的代码后，这个问题的答案其实应该是可以的，因为progressbar自己内部就处理了子线程的更新问题。 学东西，要能做到知其然，知其所以然。我对知识的掌握层次还太浅了，仅仅停留在会使用工具的层面。平时要多思考，自己给自己提出一些问题（what，why），才能加深对知识的理解。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"如何获取 Gopro 视频流","slug":"Get-gopro-video-stream","date":"2015-08-31T07:28:34.000Z","updated":"2017-04-01T10:24:09.000Z","comments":true,"path":"2015/08/31/Get-gopro-video-stream/","link":"","permalink":"http://kmfish.net/2015/08/31/Get-gopro-video-stream/","excerpt":"前言：最近的工作在研究gopro的视频流如何获取，通过搜索资料，以及对gopro app的抓包分析，得出了以下经验。这次的分析过程也体会到抓包分析的好处，以后还应进一步学习如何用好抓包工具。","text":"前言：最近的工作在研究gopro的视频流如何获取，通过搜索资料，以及对gopro app的抓包分析，得出了以下经验。这次的分析过程也体会到抓包分析的好处，以后还应进一步学习如何用好抓包工具。 如何获取Gopro的视频流以下的这些url会随gopro的型号版本而有所不同，需要自己抓包分析确定。 gopro提供了wifi和hdmi的视频输出，目前研究的是wifi输出。通过对gopro app抓包分析，和网上搜索的资料，整理出以下方法： 先通过gopro app完成和gopro的蓝牙配对，配置好wifi热点，并开启wifi热点； 手机切换至gopro的热点网络，在 udp://:8554 上开启监听。 发送http get request( http://10.5.5.9/gp/gpExec?p1=gpStreamA9&amp;c1=restart)，gopro即开始向手机的 8554 端口发送数据。手机即可在udp 8554端口收到数据。 通过抓包分析，gopro app会定期（1次/s）发送心跳请求，维持连接。udp : “GPHD:1:0:2:0” 0.3次/s // 若无此心跳，则视频流几秒后会中断http : GET /gp/gpControl/status 2次/s //若无此心跳，则gopro的wifi热点几分钟后会关闭 备注：抓包分析出gopro通信的一些url，响应均为jsonGET /bacpac/cv 返回gopro热点名称GET /gp/gpControl 返回gopro所有设置项的当前状态，可选项信息，以及所有支持的url command如： /gp/gpControl/command/wireless/pair/cancel 如果已经配对成功则取消配对 其他包gopro app 会发送mdns请求，获取gopro的ip地址及mac地址等信息；gopro app 每次进入preview界面时，会向全网发送WOL包，WOL（Wake on Lan）局域网唤醒，远程唤醒设备。 视频流格式，码率h.264，aac，mpegts流录制视频：码率范围：20mbps~60mbpshttp://zh.gopro.com/support/articles/hero4-black-recording-time-in-each-video-setting 实时预览下码率为：1mbps，帧率为30fps 上传视频1、wifi连接gopro，可以通过移动网络传输视频流ios下，可以在连接wifi热点的同时，其他数据通信自动走移动网络通道完成。android，5.0提供了新的网络api，可以给app指定使用特定网络。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"组合还是继承","slug":"组合还是继承","date":"2015-08-08T13:59:37.000Z","updated":"2017-04-01T10:22:50.000Z","comments":true,"path":"2015/08/08/组合还是继承/","link":"","permalink":"http://kmfish.net/2015/08/08/组合还是继承/","excerpt":"如题，每天在“面向对象”的我们，也常常遇到这个选择吧。刚好看书书读到这个话题，就记录下阅读的理解。","text":"如题，每天在“面向对象”的我们，也常常遇到这个选择吧。刚好看书书读到这个话题，就记录下阅读的理解。 继承要慎用，其使用场合仅限于你确信使用该技术有效的情况。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承。——《java编程思想 第四版》 p140 复合优于继承 与方法调用不同的是，继承打破了封装性。换句话说，子类依赖于其超类中特定功能的实现细节。 只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在“is-a”关系的时候，类B才应该继续类A。 为了避免这种脆弱性，可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类的时候。包装类不仅比子类更健壮，而且功能也更加强大。 ——《Effective Java》 item.16 在平时工作过程中，我自己也是更多选择组合而不是继承。但也没有个明确清晰的判断标准。和同事交流时，虽然也推荐多用组合，但也说不出个具体的缘由。平时主要是开发android app，在UI部分的代码里，自己也是大量使用组合，譬如view的复用，一些逻辑部分也是可以通过建一个xxxController，xxxManager来复用。减少Activity，Fragment内的代码量。 之前遇到过项目里的一个情形，几个类似布局的页面，实现是共同继承了一个基类。但这个基类并没有任何地方直接引用到，即项目内没有子类向上转型的地方。我认为仅仅是为了代码复用，是完全不需要继承的，把代码提到一个新类中，组合使用即可。后来这些页面之间由于需求问题，开始有更多的地方不同了，如果是在继承的情况下，改动起来反而更加复杂。因为不能轻易的去修改基类，可能会影响到其他页面。组合可以更灵活，我可以有选择的复用共同的部分，而自己继续写不同的地方，不会一股脑的继承了所有基类的细节，不用去考虑基类里的具体细节。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Why use fragment？","slug":"Why use fragment","date":"2014-09-21T13:49:13.000Z","updated":"2017-04-01T10:24:35.000Z","comments":true,"path":"2014/09/21/Why use fragment/","link":"","permalink":"http://kmfish.net/2014/09/21/Why use fragment/","excerpt":"针对这个问题，在网上搜索了下，有以下一些看法：\n\n1、fragments are more reusable than custom views.\n\n作者认为，fragment能够封装单靠view无法处理的事。自定义控件无法处理跨activity交互等事件，还是需要靠activity来完成，这会增加custom views 和activity的耦合。不利于复用。而fragment可以封装更多的东西，包括AsyncTask，file and database access等。\n\n2、the main reason to use Fragments are for the backstack and lifecyclefeatures. Otherwise, custom views are more light weight, simpler toimplement, and have the advantage that they can be nested.see here\n\n主要原因是fragment提供了backstack支持界面状态的回退，以及生命周期特性。（在SDK 17 以后fragment也支持嵌套了）","text":"针对这个问题，在网上搜索了下，有以下一些看法： 1、fragments are more reusable than custom views. 作者认为，fragment能够封装单靠view无法处理的事。自定义控件无法处理跨activity交互等事件，还是需要靠activity来完成，这会增加custom views 和activity的耦合。不利于复用。而fragment可以封装更多的东西，包括AsyncTask，file and database access等。 2、the main reason to use Fragments are for the backstack and lifecyclefeatures. Otherwise, custom views are more light weight, simpler toimplement, and have the advantage that they can be nested.see here 主要原因是fragment提供了backstack支持界面状态的回退，以及生命周期特性。（在SDK 17 以后fragment也支持嵌套了） 过去的模式：如果实现官方文档中的那个例子，手机版上是两个activity（列表和详情），pad版上则在同一activity下了。在fragment推出之前，我们之前的项目里也有实现过类似的需求。两个界面分别为 listView 和 detailView，则activityA里会同时持有两个view，当判断为手机版，则detailview会hide；当为pad版时，才会显示detailView。然后activityA里就会同时包含对两个的view的控制代码，当然也可以提出一个viewController来包含控制代码，activityA来引用viewController。这里的这个ViewController（或viewManager）就类似fragment。按照MVC的思想，activity其实就扮演了Controller的角色（或者再自己封装一个viewManager，但与系统的交互还是由activity来负责管理的。） fragment的优点：fragment同样有自己的生命周期，不用刻意担心内存泄漏的问题，而且fragment还拥有切换保留（retain）机制，可以在状态切换期间保持状态不变（如后台任务等）。另外，由于框架已经实现了对fragment的生命周期管理，所以开发时也不必在activity的生命周期回调事件代码中加入对各个组件的管理代码，代码整体更加简洁清晰。使用fragment，可以帮助开发者省下许多开发和维护的工作量。 自己的理解：通过查看fragment提供的接口，可以发现非常类似activity的接口，可以认为fragment is a “small activity“，所以相对于使用自定义view+ 控制器的方式，使用fragment可以封装更多的和系统的交互，提供更高级的封装。自定义view仅是在视图层面的封装（能够控制view的show，hide，布局的变化等），但fragment可以提供更高层面的控制（与activity交互，状态栈回退，独立的生命周期管理）。旧的方式依然需要依赖和activity的配合才能实现这些需求（如和其他activity的交互 startActiviyForResult，就可以直接在fragment里去调用了）。从整体上看，相当于将activity和可复用组件进一步解耦了，使得组件的复用性和封装性更好。activity不用再去向内部组件通知各项事件。而组件自身封装得更加完备，内部就处理了生命周期事件以及其他与系统的交互事件。在不同activity之间的复用变得更加容易灵活。从代码层面上看，activity里的代码就会少了许多，而各fragment的代码都由自己维护了。代码结构更加清晰简洁，大大降低了维护代价，也提高了项目代码的可读性。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"android camera 摄像头预览画面变形","slug":"?p=14","date":"2013-09-08T14:59:37.000Z","updated":"2017-04-01T10:23:06.000Z","comments":true,"path":"2013/09/08/?p=14/","link":"","permalink":"http://kmfish.net/2013/09/08/?p=14/","excerpt":"问题：最近在处理一下camera的问题，发现在竖屏时预览图像会变形，而横屏时正常。但有的手机则是横竖屏都会变形。\n结果：解决了预览变形的问题，同时支持前后摄像头，预览无变形，拍照生成的jpg照片方向正确。","text":"问题：最近在处理一下camera的问题，发现在竖屏时预览图像会变形，而横屏时正常。但有的手机则是横竖屏都会变形。 结果：解决了预览变形的问题，同时支持前后摄像头，预览无变形，拍照生成的jpg照片方向正确。 环境 ： android studio, xiaomi m1s android4.2 miui v5 过程： 1. 预览 preview画面变形以sdk中apidemos里的camera为例，进行修改。先重现下问题，在AndroidManifest.xml中指定了activity 的screenOrientation为landspace，则预览正常。若指定为portrait，则图像会有拉伸变形。 找到正确的previewsize继续看demo代码，mCamera.getParameters().getSupportedPreviewSizes() 可以返回当前设备支持的一组previewSize，例如： 1920x1088 1280x720 800x480 768x432 720x480 640x480 576x432 480x320384x288 352x288 320x240 240x160 176x144 而我们根据我们在界面上需要显示的预览大小，来设置camera的预览大小，即在这一组size中选择一个previewsize，找到高宽比和大小最接近的一个size。通过调用 getOptimalPreviewSize(List sizes, int w, int h) 来进行选择。注意这里的后两个参数，因为摄像头的预览size是固定的，就那么一组，其高宽比是固定的，且方向也是固定的。对于摄像头来说，都是width是长边，即width &gt; height。 所以camera的ratio计算值总是大于1的。所以当手机在横屏的时候，我们的w&gt;h，调用该方法进行选择是没问题的。但是当竖屏后，w &lt; h了，若还是直接调用该方法，则targetRatio 会小于1，按这个targetRatio去找就找不到合适的size了，那么比例不对预览自然就变形了。所以得在调用的地方进行调整，保证参数w &gt; h。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private Size getOptimalPreviewSize(List&lt;Size&gt; sizes, int w, int h) &#123; final double ASPECT_TOLERANCE = 0.1; double targetRatio = (double) w / h; if (sizes == null) return null; Size optimalSize = null; double minDiff = Double.MAX_VALUE; int targetHeight = h; // Try to find an size match aspect ratio and size for (Size size : sizes) &#123; double ratio = (double) size.width / size.height; if (Math.abs(ratio - targetRatio) &gt; ASPECT_TOLERANCE) continue; if (Math.abs(size.height - targetHeight) &lt; minDiff) &#123; optimalSize = size; minDiff = Math.abs(size.height - targetHeight); &#125; &#125; // Cannot find the one match the aspect ratio, ignore the requirement if (optimalSize == null) &#123; minDiff = Double.MAX_VALUE; for (Size size : sizes) &#123; if (Math.abs(size.height - targetHeight) &lt; minDiff) &#123; optimalSize = size; minDiff = Math.abs(size.height - targetHeight); &#125; &#125; &#125; return optimalSize;&#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // We purposely disregard child measurements because act as a // wrapper to a SurfaceView that centers the camera preview instead // of stretching it. final int width = resolveSize(getSuggestedMinimumWidth(), widthMeasureSpec); final int height = resolveSize(getSuggestedMinimumHeight(), heightMeasureSpec); setMeasuredDimension(width, height); if (mSupportedPreviewSizes != null) &#123; mPreviewSize = getOptimalPreviewSize(mSupportedPreviewSizes, Math.max(width, height), Math.min(width, height)); &#125; ...... 选择和previewsize一致的比例来布局surfaceview当我们选择了合适的previewsize后，还有一个因素会影响到预览画面是否正常。即surfaceview的布局。从demo代码可以知道要想在界面上显示camera预览画面，需要添加一个surfaceview，而我们添加了surfaceview后，就需要对其进行布局，设置其大小，位置。 经过搜索查资料，here这里有人回答了原因。 “The reason is: SurfaceView aspect ratio (width/height) MUST be same as Camera.Size aspect ratio used in preview parameters. And if aspectratio is not the same, you’ve got stretched image.” 看到这句话，理解了变形是因为比例错误。surfaceview和cameraSize的比例应该要一致。 在onlayout中，我们对surfaceview进行了layout，根据指定的surfaceview的高宽来布局。demo中会将surfacevidew居中，看代码是根据宽高比和previewsize的宽高比来对比，选择水平居中或垂直居中。前面已经说过，previewsize的width大于height，所以凡是涉及到宽高比计算的地方，两个size我们都需要保持同样的顺序，都是w &gt; h，或w &lt; h。所以当竖屏时，我们在判断前应该交换presize的w和h，才能正确布局居中surfaceview。1234567891011121314151617181920212223242526272829303132333435 protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int curOrientation = getContext().getResources().getConfiguration().orientation; if (changed &amp;&amp; getChildCount() &gt; 0 || mLastOrientation != curOrientation) &#123; mLastOrientation = curOrientation; final View child = getChildAt(0); final int width = r - l; final int height = b - t; int previewWidth = width; int previewHeight = height; if (mPreviewSize != null) &#123; previewWidth = mPreviewSize.width; previewHeight = mPreviewSize.height; if (curOrientation == Configuration.ORIENTATION_PORTRAIT) &#123; previewWidth = mPreviewSize.height; previewHeight = mPreviewSize.width; &#125; &#125; // Center the child SurfaceView within the parent. if (width * previewHeight &gt; height * previewWidth) &#123; final int scaledChildWidth = previewWidth * height / previewHeight; child.layout((width - scaledChildWidth) / 2, 0, (width + scaledChildWidth) / 2, height); &#125; else &#123; final int scaledChildHeight = previewHeight * width / previewWidth; child.layout(0, (height - scaledChildHeight) / 2, width, (height + scaledChildHeight) / 2); &#125; &#125;&#125; 至此，经过测试，设备显示正常，横屏竖屏均再无拉伸现象了。 总结下，demo工程在横屏下正常，而在竖屏下出现预览画面变形的原因主要是，onMeasure时选择previewsize和onlayout时布局surfaceview，都是基于横屏考虑的，所以w均大于h。当activity改为竖屏运行时，就需要调整这两个地方，保证比例一致，才能计算正确，从而显示正常画面。 2. 方向问题刚刚讲了变形的问题，我们应该发现当手机竖屏后，预览画面的方向没有随之改变过来，于是看上去就颠倒了。所以我们还需要处理一下方向的问题。 注意这里的“方向”包括：前置、后置摄像头画面预览方向，前置后置摄像头拍照后的图片方向。 预览方向：通过查询android文档，可以发现如下资料： For example, suppose the natural orientation of the device isportrait. The device is rotated 270 degrees clockwise, so the deviceorientation is 270. Suppose a back-facing camera sensor is mounted inlandscape and the top side of the camera sensor is aligned with theright edge of the display in natural orientation. So the cameraorientation is 90. The rotation should be set to 0 (270 + 90). （后置摄像头）可以得知，camera是在设置上是固定方向的， camera的顶部是和屏幕自然显示时的右边对齐的。说明camera默认就是横屏方向的。为了在竖屏的时候进行preview预览，我们需要调整camera的方向。 setDisplayOrientation 可以修改camera的预览方向。 If you want to make the camera image show in the same orientation asthe display, you can use the following code. 123456789101112131415161718192021222324public static void setCameraDisplayOrientation(Activity activity, int cameraId, android.hardware.Camera camera) &#123;android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo();android.hardware.Camera.getCameraInfo(cameraId, info);int rotation = activity.getWindowManager().getDefaultDisplay() .getRotation();int degrees = 0;switch (rotation) &#123; case Surface.ROTATION_0: degrees = 0; break; case Surface.ROTATION_90: degrees = 90; break; case Surface.ROTATION_180: degrees = 180; break; case Surface.ROTATION_270: degrees = 270; break;&#125;int result;if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123; result = (info.orientation + degrees) % 360; result = (360 - result) % 360; // compensate the mirror&#125; else &#123; // back-facing result = (info.orientation - degrees + 360) % 360;&#125;camera.setDisplayOrientation(result);&#125; 拍照方向：若想修改照片的方向，还需调用 camera.setRotation，google 的文档说的很清楚了，添加一个orientation listener既可以从传感器获取当前设备旋转方向，参考如下代码即可正确设置照片方向。但要注意一点，这个方向和activity方向（可以在android-manifest设置）无关。 无论activity此时是什么方向，只要获取了传感器方向均可以正确调整照片方向，与预览方面一致。 代码方面，由于这个回调调用比较频繁（设备角度一变化就会调用），可以在回调里保存下rotation，然后在拍照的时候再设置camera。由于考虑了前置摄像头，须注意传递正确的cameraId。12mCamera.setParameters(parameters);mCamera.takePicture(shutterCallback, rawCallback,jpegCallback); CameraInfo.orientation is the angle between camera orientation andnatural device orientation. The sum of the two is the rotation anglefor back-facing camera. The difference of the two is the rotationangle for front-facing camera. Note that the JPEG pictures offront-facing cameras are not mirrored as in preview display. Forexample, suppose the natural orientation of the device is portrait.The device is rotated 270 degrees clockwise, so the device orientationis 270. Suppose a back-facing camera sensor is mounted in landscapeand the top side of the camera sensor is aligned with the right edgeof the display in natural orientation. So the camera orientation is The rotation should be set to 0 (270 + 90). The reference code is as follows. 1234567891011121314public void onOrientationChanged(int orientation) &#123; if (orientation == ORIENTATION_UNKNOWN) return; android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); orientation = (orientation + 45) / 90 * 90; int rotation = 0; if (info.facing == CameraInfo.CAMERA_FACING_FRONT) &#123; rotation = (info.orientation - orientation + 360) % 360; &#125; else &#123; // back-facing camera rotation = (info.orientation + orientation) % 360; &#125; mParameters.setRotation(rotation); &#125; 3. 总结到此为止，我们基本上是实现了一个最简单的拍照应用，能支持前后摄像头，预览正确，照片方向正确。文中一些api在低版本sdk上没有，不能直接用，还须参考资料换用其他方法。由于手头设备有限，我仅仅在android4.2 小米手机上测试过，pad未测试。 补充setRotation 在一些设备上无效 拍照后得到的图像还是横屏的，所以在save前需要再rotate一下。123456789101112131415161718private Bitmap adjustPhotoRotationToPortrait(byte[] data) &#123; BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeByteArray(data, 0, data.length, options); if (options.outHeight &lt; options.outWidth) &#123; int w = options.outWidth; int h = options.outHeight; Matrix mtx = new Matrix(); mtx.postRotate(90); // Rotating Bitmap Bitmap bmp = BitmapFactory.decodeByteArray(data, 0, data.length); Bitmap rotatedBMP = Bitmap.createBitmap(bmp, 0, 0, w, h, mtx, true); return rotatedBMP; &#125; else &#123; return null; &#125;&#125;","raw":null,"content":null,"categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://kmfish.net/tags/android/"}]}]}